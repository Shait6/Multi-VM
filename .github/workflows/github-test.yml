name: Deploy Multi-Region VM Backup

on:
  workflow_dispatch:
    inputs:
      subscriptionId:
        description: 'Azure Subscription ID'
        required: true
      enableAutoRemediation:
        description: 'Enable Auto-Remediation (DeployIfNotExists)'
        required: false
        default: 'false'
        type: choice
        options: ['true','false']
      deploymentLocation:
        description: 'Subscription deployment metadata location'
        required: false
        default: 'westeurope'
        type: choice
        options: ['westeurope','northeurope','swedencentral','germanywestcentral']
      weeklyBackupDaysOfWeek:
        description: 'Weekly backup days (comma separated)'
        required: false
        default: 'Sunday,Wednesday'
      retentionProfile:
        description: 'Composite: Daily|Weekly|Yearly|TagName|TagValue (Yearly=0 disables yearly tier)'
        required: false
        default: '14|30|0|backup|true'
      backupFrequency:
        description: 'Backup frequency'
        required: false
        default: 'Weekly'
        type: choice
        options: ['Daily','Weekly','Both']
      backupScheduleTime:
        description: 'Backup schedule time (HH:mm)'
        required: false
        default: '18:30'
      backupTimeZone:
        description: 'Backup schedule time zone'
        required: false
        default: 'UTC'
      instantRestoreRetentionDays:
        description: 'Instant restore retention (days). Weekly or Both: weekly policy uses 5; daily uses this value (1â€“5).'
        required: false
        default: '2'
        type: choice
        options: ['1','2','3','4','5']

jobs:
  deploy:
    runs-on: windows-latest
    outputs:
      vmTagName: ${{ steps.deploy_backup.outputs.vmTagName }}
      vmTagValue: ${{ steps.deploy_backup.outputs.vmTagValue }}
    env:
      SUBSCRIPTION_ID: ${{ github.event.inputs.subscriptionId }}
      ENABLE_AUTO_REMEDIATION: ${{ github.event.inputs.enableAutoRemediation }}
      DEPLOYMENT_LOCATION: ${{ github.event.inputs.deploymentLocation }}
      WEEKLY_DAYS: ${{ github.event.inputs.weeklyBackupDaysOfWeek }}
      BACKUP_FREQUENCY: ${{ github.event.inputs.backupFrequency }}
      RETENTION_PROFILE: ${{ github.event.inputs.retentionProfile }}
      VM_TAG_NAME: ''
      VM_TAG_VALUE: ''
      BACKUP_TIME: ${{ github.event.inputs.backupScheduleTime }}
      BACKUP_TZ: ${{ github.event.inputs.backupTimeZone }}
      INSTANT_RESTORE_DAYS: ${{ github.event.inputs.instantRestoreRetentionDays }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.serivcon }}

      - name: Bicep build (syntax check)
        shell: pwsh
        run: |
          try { az bicep version | Out-Null } catch { az bicep install }
          az bicep build --file main.bicep --outdir bicep-build

      - name: Deploy multi-region backup (subscription scope)
        id: deploy_backup
        shell: pwsh
        run: |
          az account set --subscription "$env:SUBSCRIPTION_ID"
          $days = $env:WEEKLY_DAYS.Split(',') | ForEach-Object { $_.Trim() }
          # Instant restore retention: force 5 when Weekly is selected
          $instant = [int]$env:INSTANT_RESTORE_DAYS
          if ($env:BACKUP_FREQUENCY -eq 'Weekly') { $instant = 5 }
          echo "Computed instant restore retention days (parameter): $instant"
          if ($env:BACKUP_FREQUENCY -eq 'Weekly') { echo 'Weekly policy will use 5 days (enforced).'}
          if ($env:BACKUP_FREQUENCY -eq 'Both')   { echo "Weekly policy will use 5 days; daily uses $instant day(s)." }
          # Parse composite retention profile Daily|Weekly|Yearly|TagName|TagValue
          $profileParts = $env:RETENTION_PROFILE.Split('|')
          if ($profileParts.Count -lt 5) { throw "Invalid retentionProfile format. Expected Daily|Weekly|Yearly|TagName|TagValue (e.g. 14|30|10|backup|true)." }
          $dailyRetention  = [int]$profileParts[0]
          $weeklyRetention = [int]$profileParts[1]
          $yearlyRetention = [int]$profileParts[2]
          $tagName         = $profileParts[3]
          $tagValue        = $profileParts[4]
          $enableYearly = $yearlyRetention -gt 0
          echo "Parsed profile -> Daily=$dailyRetention Weekly=$weeklyRetention Yearly=$yearlyRetention TagName=$tagName TagValue=$tagValue (enableYearly=$enableYearly)"
          # Write tag outputs for next job
            # Prepare parameters
            $paramObj = @{
              backupFrequency        = @{ value = $env:BACKUP_FREQUENCY }
              dailyRetentionDays     = @{ value = $dailyRetention }
              weeklyRetentionDays    = @{ value = $weeklyRetention }
              weeklyBackupDaysOfWeek = @{ value = $days }
              backupScheduleRunTimes = @{ value = @($env:BACKUP_TIME) }
              backupTimeZone         = @{ value = $env:BACKUP_TZ }
              instantRestoreRetentionDays = @{ value = $instant }
              enableMonthlyRetention = @{ value = $false }
              enableYearlyRetention  = @{ value = $enableYearly }
              yearlyRetentionYears   = @{ value = $yearlyRetention }
            }
            $paramObj | ConvertTo-Json -Depth 5 | Out-File main-params.json -Encoding utf8
            $deployName = "gh-multi-region-$(Get-Date -Format yyyyMMddHHmmss)"
            echo "Starting deployment $deployName with frequency=$env:BACKUP_FREQUENCY days=$env:WEEKLY_DAYS"
            az deployment sub create --name $deployName --location "$env:DEPLOYMENT_LOCATION" --template-file main.bicep --parameters @main-params.json -o json > gh-deployment.json
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Subscription deployment failed with exit code $LASTEXITCODE"
              if (Test-Path gh-deployment.json) { Get-Content gh-deployment.json | Write-Host }
              exit $LASTEXITCODE
            }
            $outputs = az deployment sub show --name $deployName --query properties.outputs -o json | ConvertFrom-Json
            $outputs | ConvertTo-Json -Depth 10 | Out-File gh-deployment-outputs.json -Encoding utf8
            echo "Vaults: $($outputs.vaultIds.value -join ', ')"
            echo "Policies: $($outputs.backupPolicyNames.value -join ', ')"
            echo "UAIs: $($outputs.userAssignedIdentityIds.value -join ', ')"
            echo "Principals: $($outputs.userAssignedIdentityPrincipalIds.value -join ', ')"
            # Set step outputs using GITHUB_OUTPUT
            $outFile = $env:GITHUB_OUTPUT
            "vmTagName=$tagName"  | Out-File -FilePath $outFile -Append
            "vmTagValue=$tagValue" | Out-File -FilePath $outFile -Append

  remediate:
    if: ${{ github.event.inputs.enableAutoRemediation == 'true' }}
    needs: deploy
    runs-on: windows-latest
    env:
      SUBSCRIPTION_ID: ${{ github.event.inputs.subscriptionId }}
      DEPLOYMENT_LOCATION: ${{ github.event.inputs.deploymentLocation }}
      VM_TAG_NAME: ${{ needs.deploy.outputs.vmTagName }}
      VM_TAG_VALUE: ${{ needs.deploy.outputs.vmTagValue }}
      WAIT_MINUTES: '5'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.serivcon }}

      - name: Remediate tagged VMs (baseline region)
        shell: pwsh
        run: |
          az account set --subscription "$env:SUBSCRIPTION_ID"

          $wait = [int]$env:WAIT_MINUTES
          if ($wait -gt 0) { Write-Host "Waiting $wait minute(s) before remediation..."; Start-Sleep -Seconds ($wait * 60) }

          $r = $env:DEPLOYMENT_LOCATION
          $vaultName = "rsv-$r"
          $vaultRg   = "rsv-rg-$r"
          $policyName = "backup-policy-$r"
          $uaiId = "/subscriptions/$env:SUBSCRIPTION_ID/resourceGroups/$vaultRg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/uai-$r"

          echo "Deploying policy assignment for region=$r vault=$vaultName policy=$policyName"
          az deployment sub create `
            --name "remediate-policy-$r-$(Get-Date -Format yyyyMMddHHmmss)" `
            --location $r `
            --template-file modules/backupAutoEnablePolicy.bicep `
            --parameters `
              assignmentLocation=$r `
              assignmentIdentityId=$uaiId `
              vmTagName=$env:VM_TAG_NAME `
              vmTagValue=$env:VM_TAG_VALUE `
              vaultName=$vaultName `
              vaultResourceGroup=$vaultRg `
              backupPolicyName=$policyName `
            -o none

          $assign = az policy assignment show -n enable-vm-backup-assignment -o json | ConvertFrom-Json
          if ($null -ne $assign) {
            $remName = "remediate-vm-backup-$r"
            echo "Starting remediation: $remName"
            az policy remediation create -n $remName --policy-assignment $assign.id --resource-discovery-mode ExistingNonCompliant -o none
          } else {
            echo "Warning: Policy assignment not found after deployment in region $r"
          }
          
